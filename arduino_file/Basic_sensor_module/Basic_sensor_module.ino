/*********
 Electric (EV) & Autonomous vehicle (AV) module kit
 By FABLab Bangkok
*********/

#include <Wire.h>
#include <Adafruit_INA219.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <MPU6050.h>

#define light 2                     // analog pin header of light sensor
const float ADC_REF_VOLTAGE = 5.0;  // Reference voltage (adjust if 3.3V)
const int ADC_RESOLUTION = 4095;    // For 12-bit ADC
Adafruit_INA219 ina219;             // Battery monitoring sensor
//---------------------------------------------------------------------------
MPU6050 mpu;                           // IMU sensor
int16_t axr, ayr, azr, gxr, gyr, gzr;  // Setup IMU variable
// Choose full-scale ranges and matching scale constants
//  Accel: 0=±2g, 1=±4g, 2=±8g, 3=±16g
//  Gyro : 0=±250, 1=±500, 2=±1000, 3=±2000 °/s

const uint8_t ACCEL_RANGE = 1;  // ±4g
const uint8_t GYRO_RANGE = 1;   // ±500 dps

// Scale factors (LSB per unit) for the chosen ranges:
const float ACC_SCALE = 8192.0f;  // LSB/g for ±4g
const float GYR_SCALE = 65.5f;    // LSB/(°/s) for ±500 dps

// Optional: enter your factory/calibrated offsets (in raw LSB units)
const int16_t AX_OFF = 0, AY_OFF = 0, AZ_OFF = 0;
const int16_t GX_OFF = 0, GY_OFF = 0, GZ_OFF = 0;

// Complementary filter state
float roll_deg = 0.0f;   // x-axis rotation
float pitch_deg = 0.0f;  // y-axis rotation
float alpha = 0.98f;     // 0.96–0.99; higher = more gyro trust (gyroscope bias)

uint32_t lastMicros = 0;  // timestamp setup
// (1 Radian = 57.3 degree = 180/PI
static inline float rad2deg(float r) {
  return r * 180.0f / PI;
}
//-----------------------------------------------------------------
int light_value;  // Light sensor value 0-4095
#define SCREEN_WIDTH 128  // OLED display width, in pixels
#define SCREEN_HEIGHT 64  // OLED display height, in pixels

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
// The -1 parameter means no reset pin, which is common for built-in OLEDs.
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);
// 'FabLab Bangkok Logo Black', 128x64px
const unsigned char FABLAB[] PROGMEM = {
  0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xfe, 0x02, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf8, 0x0f, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf0, 0x1f, 0x80, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xc0, 0x3f, 0xe0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xc0, 0x7f, 0xe0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x80, 0xff, 0xf8, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x00, 0x7f, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff,
  0xfe, 0x00, 0x39, 0xfe, 0x07, 0xff, 0x80, 0xf3, 0xf0, 0x1e, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff,
  0xfe, 0x00, 0x00, 0x7f, 0x03, 0xff, 0x80, 0xf1, 0xf0, 0x0e, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff,
  0xfc, 0x00, 0x00, 0x1f, 0x83, 0xff, 0x9f, 0xf1, 0xf3, 0xce, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff,
  0xf8, 0x70, 0x00, 0x0f, 0xe1, 0xff, 0x9f, 0xe1, 0xf3, 0xce, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff,
  0xf8, 0xf8, 0x00, 0x0f, 0xf0, 0xff, 0x9f, 0xe1, 0xf3, 0xce, 0xfe, 0x1c, 0x8f, 0xff, 0xff, 0xff,
  0xf1, 0xfc, 0x00, 0x07, 0xf8, 0xff, 0x9f, 0xe4, 0xf3, 0xce, 0xfd, 0xdc, 0x67, 0xff, 0xff, 0xff,
  0xfb, 0xfc, 0x00, 0x07, 0xfc, 0xff, 0x9f, 0xcc, 0xf0, 0x1e, 0xff, 0xcc, 0xe7, 0xff, 0xff, 0xff,
  0xff, 0xfc, 0x00, 0x07, 0xff, 0xff, 0x80, 0xcc, 0xf0, 0x1e, 0xff, 0xcc, 0xf7, 0xff, 0xff, 0xff,
  0xff, 0xfc, 0x00, 0x07, 0xff, 0xbf, 0x80, 0xce, 0x73, 0xce, 0xff, 0x0c, 0xf7, 0xff, 0xff, 0xff,
  0xef, 0xfc, 0x00, 0x07, 0xff, 0x3f, 0x9f, 0xce, 0x73, 0xee, 0xfe, 0x4c, 0xf7, 0xff, 0xff, 0xff,
  0xcf, 0xfe, 0x00, 0x0f, 0xff, 0x1f, 0x9f, 0x80, 0x73, 0xe6, 0xfc, 0xcc, 0xf7, 0xff, 0xff, 0xff,
  0xcf, 0xff, 0x00, 0x0f, 0xff, 0x1f, 0x9f, 0x80, 0x33, 0xe6, 0xfd, 0xcc, 0xf7, 0xff, 0xff, 0xff,
  0xcf, 0xff, 0x00, 0x1f, 0xff, 0x1f, 0x9f, 0x9f, 0x33, 0xce, 0xfd, 0xcc, 0xf7, 0xff, 0xff, 0xff,
  0x8f, 0xff, 0x80, 0x3f, 0xff, 0x1f, 0x9f, 0x3f, 0x30, 0x0e, 0x04, 0xcc, 0x67, 0xff, 0xff, 0xff,
  0x8f, 0xff, 0xf0, 0xff, 0xff, 0x0f, 0x9f, 0x3f, 0x30, 0x1e, 0x06, 0x2d, 0x0f, 0xff, 0xff, 0xff,
  0x8f, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x8f, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x8f, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x8f, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x8f, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x8f, 0xc7, 0xff, 0xfc, 0x18, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x0f, 0x83, 0xff, 0xf8, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x0f, 0x01, 0xff, 0xf8, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x0f, 0x00, 0xff, 0xf0, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x0f, 0x00, 0x7f, 0xe0, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x8f, 0x00, 0x7f, 0xe0, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x8f, 0x00, 0x3f, 0xc0, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x8f, 0x00, 0x3f, 0xc0, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xfc, 0xff, 0xff,
  0x8f, 0x00, 0x3f, 0xc0, 0x01, 0x0f, 0x80, 0xfe, 0x7e, 0x7c, 0xf8, 0x1e, 0x7c, 0xf0, 0x3e, 0xf9,
  0x8f, 0x00, 0x1f, 0xc0, 0x03, 0x0f, 0x80, 0x7c, 0x7e, 0x7c, 0xf0, 0x0e, 0x79, 0xe0, 0x1e, 0xf3,
  0x8f, 0x00, 0x1f, 0x80, 0x07, 0x0f, 0x9e, 0x7c, 0x3e, 0x3c, 0xe3, 0xce, 0x71, 0xc7, 0x9e, 0xf3,
  0x8f, 0x00, 0x1f, 0x80, 0x0f, 0x0f, 0x9e, 0x7c, 0x3e, 0x1c, 0xe7, 0xfe, 0x73, 0xcf, 0x8e, 0xe7,
  0x8f, 0x80, 0x1f, 0x80, 0x0f, 0x1f, 0x9e, 0x79, 0x3e, 0x1c, 0xe7, 0xfe, 0x67, 0x9f, 0xce, 0xe7,
  0xcf, 0x80, 0x1f, 0x80, 0x0f, 0x1f, 0x9c, 0x79, 0x1e, 0x0c, 0xcf, 0xfe, 0x67, 0x9f, 0xce, 0xcf,
  0xcf, 0xc0, 0x1f, 0x80, 0x0f, 0x1f, 0x80, 0xf9, 0x9e, 0x4c, 0xcf, 0xfe, 0x47, 0x9f, 0xee, 0xcf,
  0xcf, 0xc0, 0x1f, 0x80, 0x1f, 0x1f, 0x80, 0xf9, 0x9e, 0x44, 0xcf, 0x8e, 0x47, 0x9f, 0xee, 0x8f,
  0xef, 0xc0, 0x1f, 0x80, 0x1f, 0x3f, 0x9e, 0x73, 0x9e, 0x64, 0xcf, 0x8e, 0x07, 0x9f, 0xce, 0x07,
  0xef, 0xc0, 0x3f, 0xc0, 0x3f, 0x3f, 0x9e, 0x73, 0x8e, 0x70, 0xef, 0xee, 0x13, 0x9f, 0xce, 0x27,
  0xe7, 0xc0, 0x3f, 0xc0, 0x7c, 0x3f, 0x9f, 0x70, 0x0e, 0x70, 0xe7, 0xee, 0x33, 0x9f, 0xce, 0x63,
  0xf3, 0xc0, 0x7f, 0xe0, 0xf8, 0x7f, 0x9e, 0x60, 0x0e, 0x78, 0xe7, 0xee, 0x79, 0xcf, 0x8e, 0x73,
  0xf0, 0xc0, 0xff, 0xf1, 0xf0, 0x7f, 0x9e, 0x67, 0xc6, 0x78, 0xf3, 0xce, 0x79, 0xc7, 0x1e, 0xf3,
  0xf8, 0x40, 0xff, 0xff, 0xe0, 0xff, 0x80, 0x67, 0xe6, 0x7c, 0xf0, 0x0e, 0x7c, 0xe0, 0x3e, 0xf9,
  0xf8, 0x00, 0xff, 0xff, 0xc0, 0xff, 0x80, 0xe7, 0xe6, 0x7c, 0xfc, 0x1e, 0x7c, 0xf0, 0x7e, 0xf9,
  0xfc, 0x00, 0xff, 0xff, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xfc, 0x00, 0xff, 0xfe, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xfe, 0x00, 0xff, 0xfc, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x00, 0xff, 0xf8, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x00, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x80, 0x7f, 0xe0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xc0, 0x3f, 0x80, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf0, 0x1f, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf8, 0x0e, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xfc, 0x06, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0x06, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfe, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

void setup() {
  Serial.begin(115200);
  pinMode(light, INPUT);
  light_value = analogRead(light);
  // Start I2C Communication SDA = 5 and SCL = 4 on Wemos Lolin32 ESP32 with built-in SSD1306 OLED
  // Make sure these pins match your specific ESP32 board and OLED connection.
  Wire.begin(5, 4);

  // Initialize the OLED display
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C, false, false)) {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;)
      ;  // Don't proceed, loop forever
  }
  delay(2000);  // Pause for 2 seconds to allow the display to initialize
  // Clear the display buffer before drawing anything
  display.clearDisplay();
  // --- Code to display text ---
  // You can add more text with different positions and sizes
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(20, 20);  // Move cursor to x=0, y=20
  display.println("WELCOME");
  delay(1000);
  display.clearDisplay();

  //Display FABLab Bangkok Logo
  display.drawBitmap(0, 0, FABLAB, 128, 64, SSD1306_WHITE);
  display.display();  // Show the content of the buffer on the OLED
  delay(1000);
  display.clearDisplay();

  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(10, 10);
  display.println("Initializing INA219...");
  // Display everything that's been drawn to the buffer on the screen
  display.display();
  delay(1000);

  // Clear the display buffer before drawing anything
  display.clearDisplay();

  while (!Serial) {
    ;
  }
  Serial.println("Initializing INA219 for Battery Monitoring...");
  if (!ina219.begin()) {
    Serial.println("Failed to find INA219 chip");
    while (1) {
      delay(10);
    }
  }
  ina219.setCalibration_32V_2A();
  // ****Battery voltage calibration******
  // To use a slightly lower 32V, 1A range (higher precision on amps):
  //ina219.setCalibration_32V_1A();
  // Or to use a lower 16V, 400mA range (higher precision on volts and amps):
  //ina219.setCalibration_16V_400mA();
  delay(1000);  //
  Serial.println("INA219 initialized successfully!");

  // Init MPU6050
  Serial.println("Initializing MPU6050...");
  mpu.initialize();
  if (!mpu.testConnection()) {
    Serial.println("MPU6050 connection failed");
    while (1)
      ;
  } else {
    Serial.println("MPU6050 ready");
  }
  // Set ranges
  mpu.setFullScaleAccelRange(ACCEL_RANGE);
  mpu.setFullScaleGyroRange(GYRO_RANGE);
  // Apply optional offsets (comment out if not calibrated)
  if (AX_OFF || AY_OFF || AZ_OFF || GX_OFF || GY_OFF || GZ_OFF) {
    mpu.setXAccelOffset(AX_OFF);
    mpu.setYAccelOffset(AY_OFF);
    mpu.setZAccelOffset(AZ_OFF);
    mpu.setXGyroOffset(GX_OFF);
    mpu.setYGyroOffset(GY_OFF);
    mpu.setZGyroOffset(GZ_OFF);
  }
  // Seed the filter with accelerometer tilt to avoid a jump at start
  mpu.getMotion6(&axr, &ayr, &azr, &gxr, &gyr, &gzr);
  {
    float ax = axr / ACC_SCALE;
    float ay = ayr / ACC_SCALE;
    float az = azr / ACC_SCALE;
    float accRoll = rad2deg(atan2f(ay, az));
    float accPitch = rad2deg(atan2f(-ax, sqrtf(ay * ay + az * az)));
    roll_deg = accRoll;
    pitch_deg = accPitch;
  }
  lastMicros = micros();
  Serial.println("Ready. Printing roll° and pitch° (complementary filter).");
}
void loop() {
  float busVoltage = ina219.getBusVoltage_V();  // Voltage (V)
  float current_mA = ina219.getCurrent_mA();    // Current (mA)
  float power_mW = ina219.getPower_mW();        // Power (mW)
  Serial.print("Battery Voltage: ");
  Serial.print(busVoltage);
  Serial.println(" V");
  Serial.print("Current:         ");
  Serial.print(current_mA);
  Serial.println(" mA");
  Serial.print("Power:           ");
  Serial.print(power_mW);
  Serial.println(" mW");

  // Light sensor calibration
  light_value = analogRead(light);
  float voltage = light_value * (ADC_REF_VOLTAGE / ADC_RESOLUTION);
  // Convert to lux (approximation)
  // Formula based on tests: lux ≈ (voltage * 2) * 1000
  // This assumes linear output: ~1V = 1000 lux
  // 1V output ≈ 1000 lux (from empirical measurements)
  //Thus, lux = voltage * 1000 / 0.5 = voltage * 2000 (since at 0.5V ≈ 500 lux)
  float lux = (voltage * 2.0) * 1000;

  Serial.print("Raw Light data: ");
  Serial.print(light_value);
  Serial.print(" | Voltage: ");
  Serial.print(voltage);
  Serial.print(" V | Approx Lux: ");
  Serial.println(lux);

  // MPU6050 calibration (acceleration & gyro)
  // Time step (s)
  uint32_t now = micros();
  float dt = (now - lastMicros) * 1e-6f;
  lastMicros = now;
  if (dt <= 0.0f || dt > 0.25f) dt = 0.01f;  // guard against pauses
  // Read MPU6050 (acceleration & gyro)
  mpu.getMotion6(&axr, &ayr, &azr, &gxr, &gyr, &gzr);
  // Convert to physical units
  float ax = axr / ACC_SCALE;  // g
  float ay = ayr / ACC_SCALE;  // g
  float az = azr / ACC_SCALE;  // g
  float gx = gxr / GYR_SCALE;  // deg/s about X
  float gy = gyr / GYR_SCALE;  // deg/s about Y
  // float gz = gzr / GYR_SCALE; // deg/s about Z (yaw rate, not used here)

  // Accelerometer-only angles (degrees)
  // Roll  (x-axis)  = atan2(Ay, Az)
  // Pitch (y-axis)  = atan2(-Ax, sqrt(Ay^2 + Az^2))
  float accRoll = rad2deg(atan2f(ay, az));
  float accPitch = rad2deg(atan2f(-ax, sqrtf(ay * ay + az * az)));

  // Gyro integration (deg) (+= --> x=x+y ---> Roll degree = Roll degree + (gx * dt)
  roll_deg += gx * dt;
  pitch_deg += gy * dt;

  // Complementary filter
  roll_deg = alpha * roll_deg + (1.0f - alpha) * accRoll;
  pitch_deg = alpha * pitch_deg + (1.0f - alpha) * accPitch;

  // Output @ ~50 Hz
  static uint32_t lastPrint = 0;
  if (millis() - lastPrint > 20) {
    lastPrint = millis();
    Serial.print("Roll: ");
    Serial.print(roll_deg, 2);
    Serial.print("°   ");
    Serial.print("Pitch: ");
    Serial.print(pitch_deg, 2);
    Serial.println("°");
  }

  Serial.println("----------------------------");

  // Examine current direction
  if (current_mA > 0) {
    Serial.println("    (Battery is DISCHARGING)");
  } else if (current_mA < 0) {
    Serial.println("    (Battery is CHARGING)");
  } else {
    Serial.println("    (No current flow)");
  }

  Serial.println("");
  // --- OLED Display ---
  display.clearDisplay();  
  // Display Voltage
  display.setTextSize(2);   
  display.setCursor(0, 0);  // initial position (X, Y)
  display.print("V: ");
  display.print(busVoltage, 2);
  display.println("V");

  // Display current
  display.setTextSize(2);    
  display.setCursor(0, 24);  
  display.print("I: ");
  display.print(current_mA, 0);
  display.println("mA");

  // Display power
  display.setTextSize(2);    
  display.setCursor(0, 48);  
  display.print("P: ");
  display.print(power_mW / 1000.0, 2);
  display.println("W");

  display.display();         // Updating information on OLED screen
  delay(1000);  
}